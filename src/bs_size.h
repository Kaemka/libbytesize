#ifndef _BS_SIZE_H
#define _BS_SIZE_H

#include <glib.h>
#include <glib-object.h>

G_BEGIN_DECLS

#define BS_TYPE_SIZE            (bs_size_get_type())
#define BS_SIZE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), BS_TYPE_SIZE, BSSize))
#define BS_IS_SIZE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj)), BS_TYPE_SIZE)
#define BS_SIZE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), BS_TYPE_SIZE, BSSizeClass))
#define BS_IS_SIZE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), BS_TYPE_SIZE))
#define BS_SIZE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), BS_TYPE_SIZE, BSSizeClass))

/**
 * BS_SIZE_ERROR:
 *
 * Error domain for errors generated by attempts to do inappropriate operations
 * with #BSSize instances.
 */
#define BS_SIZE_ERROR bs_size_error_quark ()

/**
 * BSSizeError:
 * @BS_SIZE_ERROR_INVALID_SPEC: invalid size or unit spec provided
 * @BS_SIZE_ERROR_OVER: a value is over the limits imposed by a type
 * @BS_SIZE_ERROR_ZERO_DIV: an attemtp to do division by zero
 *
 * Error codes that identify various errors that can occur while working with
 * #BSSize instances.
 */
typedef enum {
    BS_SIZE_ERROR_INVALID_SPEC,
    BS_SIZE_ERROR_OVER,
    BS_SIZE_ERROR_ZERO_DIV,
} BSSizeError;

/**
 * BSBunit:
 *
 * Binary units (multiples of 1024) of size in bytes.
 */
typedef enum {
    BS_BUNIT_B = 0, BS_BUNIT_KiB, BS_BUNIT_MiB, BS_BUNIT_GiB, BS_BUNIT_TiB,
    BS_BUNIT_PiB, BS_BUNIT_EiB, BS_BUNIT_ZiB, BS_BUNIT_YiB, BS_BUNIT_UNDEF,
} BSBunit;

/**
 * BSDunit:
 *
 * Decimal units (multiples of 1000) of size in bytes.
 */
typedef enum {
    BS_DUNIT_B = 20, BS_DUNIT_KB, BS_DUNIT_MB, BS_DUNIT_GB, BS_DUNIT_TB,
    BS_DUNIT_PB, BS_DUNIT_EB, BS_DUNIT_ZB, BS_DUNIT_YB, BS_DUNIT_UNDEF,
} BSDunit;

/**
 * BSRoundDir:
 *
 * Rounding direction for rounding operations.
 */
typedef enum {
    BS_ROUND_DIR_UP,
    BS_ROUND_DIR_DOWN,
} BSRoundDir;

/**
 * BSUnit:
 * @bunit: a binary unit
 * @dunit: a decimal unit
 *
 * Generic unit fo size in bytes.
 */
typedef union {
    BSBunit bunit;
    BSDunit dunit;
} BSUnit;

/* use 256 bits of precision for floating point numbets, that should be more
   than enough */
/**
 * BS_FLOAT_PREC_BITS:
 *
 * Precision (in bits) of floating-point numbers used internally.
 */
#define BS_FLOAT_PREC_BITS 256

typedef struct _BSSize        BSSize;
typedef struct _BSSizeClass   BSSizeClass;
typedef struct _BSSizePrivate BSSizePrivate;

GType bs_size_get_type (void);

/* Constructors */
BSSize* bs_size_new (void);
BSSize* bs_size_new_from_bytes (guint64 bytes, gint sgn);
BSSize* bs_size_new_from_str (const gchar *size_str, GError **error);
BSSize* bs_size_new_from_size (const BSSize *size);

/* Query functions */
guint64 bs_size_get_bytes (const BSSize *size, gint *sgn, GError **error);
gint bs_size_sgn (const BSSize *size);
gchar* bs_size_get_bytes_str (const BSSize *size);
gchar* bs_size_convert_to (const BSSize *size, BSUnit unit, GError **error);
gchar* bs_size_human_readable (const BSSize *size, BSBunit min_unit, gint max_places, gboolean xlate);

/* Arithmetic */
BSSize* bs_size_add (const BSSize *size1, const BSSize *size2);
BSSize* bs_size_grow (BSSize *size1, const BSSize *size2);
BSSize* bs_size_add_bytes (const BSSize *size, guint64 bytes);
BSSize* bs_size_grow_bytes (BSSize *size, guint64 bytes);
BSSize* bs_size_sub (const BSSize *size1, const BSSize *size2);
BSSize* bs_size_shrink (BSSize *size1, const BSSize *size2);
BSSize* bs_size_sub_bytes (const BSSize *size, guint64 bytes);
BSSize* bs_size_shrink_bytes (BSSize *size, guint64 bytes);
BSSize* bs_size_mul_int (const BSSize *size, guint64 times);
BSSize* bs_size_grow_mul_int (BSSize *size, guint64 times);
BSSize* bs_size_mul_float_str (const BSSize *size, const gchar *float_str, GError **error);
BSSize* bs_size_grow_mul_float_str (BSSize *size, const gchar *float_str, GError **error);
guint64 bs_size_div (const BSSize *size1, const BSSize *size2, gint *sgn, GError **error);
BSSize* bs_size_div_int (const BSSize *size, guint64 divisor, GError **error);
BSSize* bs_size_shrink_div_int (BSSize *size, guint64 shrink_divisor, GError **error);
gchar* bs_size_true_div (const BSSize *size1, const BSSize *size2, GError **error);
gchar* bs_size_true_div_int (const BSSize *size, guint64 divisor, GError **error);
BSSize* bs_size_mod (const BSSize *size1, const BSSize *size2, GError **error);
BSSize* bs_size_round_to_nearest (const BSSize *size, const BSSize *round_to, BSRoundDir dir, GError **error);

/* Comparisons */
gint bs_size_cmp (const BSSize *size1, const BSSize *size2, gboolean abs);
gint bs_size_cmp_bytes (const BSSize *size1, guint64 bytes, gboolean abs);

G_END_DECLS

#endif  /* _BS_SIZE_H */
